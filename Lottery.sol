// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Chainlink contracts
interface LinkTokenInterface 
{
    function allowance(address owner, address spender) external view returns (uint256 remaining);

    function approve(address spender, uint256 value) external returns (bool success);

    function balanceOf(address owner) external view returns (uint256 balance);

    function decimals() external view returns (uint8 decimalPlaces);

    function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);

    function increaseApproval(address spender, uint256 subtractedValue) external;

    function name() external view returns (string memory tokenName);

    function symbol() external view returns (string memory tokenSymbol);

    function totalSupply() external view returns (uint256 totalTokensIssued);

    function transfer(address to, uint256 value) external returns (bool success);

    function transferAndCall(
        address to,
        uint256 value,
        bytes calldata data
    ) external returns (bool success);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool success);
}

contract VRFRequestIDBase 
{
    /**
    * @notice returns the seed which is actually input to the VRF coordinator
    *
    * @dev To prevent repetition of VRF output due to repetition of the
    * @dev user-supplied seed, that seed is combined in a hash with the
    * @dev user-specific nonce, and the address of the consuming contract. The
    * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
    * @dev the final seed, but the nonce does protect against repetition in
    * @dev requests which are included in a single block.
    *
    * @param _userSeed VRF seed input provided by user
    * @param _requester Address of the requesting contract
    * @param _nonce User-specific nonce at the time of the request
    */
    function makeVRFInputSeed(
        bytes32 _keyHash,
        uint256 _userSeed,
        address _requester,
        uint256 _nonce
    ) internal pure returns (uint256) {
        return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
    }

    /**
    * @notice Returns the id for this request
    * @param _keyHash The serviceAgreement ID to be used for this request
    * @param _vRFInputSeed The seed to be passed directly to the VRF
    * @return The id for this request
    *
    * @dev Note that _vRFInputSeed is not the seed passed by the consuming
    * @dev contract, but the one generated by makeVRFInputSeed
    */
    function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
    }
}

abstract contract VRFConsumerBase is VRFRequestIDBase 
{
    /**
    * @notice fulfillRandomness handles the VRF response. Your contract must
    * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
    * @notice principles to keep in mind when implementing your fulfillRandomness
    * @notice method.
    *
    * @dev VRFConsumerBase expects its subcontracts to have a method with this
    * @dev signature, and will call it once it has verified the proof
    * @dev associated with the randomness. (It is triggered via a call to
    * @dev rawFulfillRandomness, below.)
    *
    * @param requestId The Id initially returned by requestRandomness
    * @param randomness the VRF output
    */
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;

    /**
    * @dev In order to keep backwards compatibility we have kept the user
    * seed field around. We remove the use of it because given that the blockhash
    * enters later, it overrides whatever randomness the used seed provides.
    * Given that it adds no security, and can easily lead to misunderstandings,
    * we have removed it from usage and can now provide a simpler API.
    */
    uint256 private constant USER_SEED_PLACEHOLDER = 0;

    /**
    * @notice requestRandomness initiates a request for VRF output given _seed
    *
    * @dev The fulfillRandomness method receives the output, once it's provided
    * @dev by the Oracle, and verified by the vrfCoordinator.
    *
    * @dev The _keyHash must already be registered with the VRFCoordinator, and
    * @dev the _fee must exceed the fee specified during registration of the
    * @dev _keyHash.
    *
    * @dev The _seed parameter is vestigial, and is kept only for API
    * @dev compatibility with older versions. It can't *hurt* to mix in some of
    * @dev your own randomness, here, but it's not necessary because the VRF
    * @dev oracle will mix the hash of the block containing your request into the
    * @dev VRF seed it ultimately uses.
    *
    * @param _keyHash ID of public key against which randomness is generated
    * @param _fee The amount of LINK to send with the request
    *
    * @return requestId unique ID for this request
    *
    * @dev The returned requestId can be used to distinguish responses to
    * @dev concurrent requests. It is passed as the first argument to
    * @dev fulfillRandomness.
    */
    function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {
        LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
        // This is the seed passed to VRFCoordinator. The oracle will mix this with
        // the hash of the block containing this request to obtain the seed/input
        // which is finally passed to the VRF cryptographic machinery.
        uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
        // nonces[_keyHash] must stay in sync with
        // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above
        // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).
        // This provides protection against the user repeating their input seed,
        // which would result in a predictable/duplicate output, if multiple such
        // requests appeared in the same block.
        nonces[_keyHash] = nonces[_keyHash] + 1;
        return makeRequestId(_keyHash, vRFSeed);
    }

    LinkTokenInterface internal immutable LINK;
    address private immutable vrfCoordinator;

    // Nonces for each VRF key from which randomness has been requested.
    //
    // Must stay in sync with VRFCoordinator[_keyHash][this]
    mapping(bytes32 => uint256) /* keyHash */ /* nonce */
        private nonces;

    /**
    * @param _vrfCoordinator address of VRFCoordinator contract
    * @param _link address of LINK token contract
    *
    * @dev https://docs.chain.link/docs/link-token-contracts
    */
    constructor(address _vrfCoordinator, address _link) {
        vrfCoordinator = _vrfCoordinator;
        LINK = LinkTokenInterface(_link);
    }

    // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
    // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
    // the origin of the call
    function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {
        require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
        fulfillRandomness(requestId, randomness);
    }
}

abstract contract Lottery is VRFConsumerBase
{
    // Lottery
    struct TicketBalance
    {
        uint256 balance;
        uint256 timestamp;
        address owner;
    }

    event TicketsBought(address indexed from, uint256 amount);
    event LotteryAwarded(address indexed to, uint256 value);
    event LotteryRollover(uint256 value);

    mapping(address => uint256) internal _holderIndexes;
    mapping(uint256 => TicketBalance) internal _ticketBalances;
    
    uint256 internal _ticketCount;
    uint256 internal _holderCount;

    uint256 internal _ticketPrice;

    mapping (address => uint256) internal _tRewards;
    uint internal _tUnclaimedRewards;
    
    address internal _lotteryWallet;
    uint256 internal _lotteryStart;
    uint256 internal _lotteryDuration;

    function lotteryPool() public view virtual returns (uint256) {}
    function buyTickets() public payable virtual returns (bool) { }
    function claimReward(address account) public virtual returns (bool) { }

    function _checkLottery() internal virtual { }
    function _lotteryRollover() internal virtual returns (bool) { }
    function _drawLottery(uint256 randomNumber) internal virtual { }
    function _claimReward(address account) internal virtual { }

    // Chainlink
    bytes32 internal _vrfKeyHash;
    uint256 internal _vrfFee;
    bool internal _vrfLocked;

    /*
        Lottery functions
    */

    function ticketPrice() public view returns (uint256)
    {
        return _ticketPrice;
    }

    function totalUnclaimedRewards() public view returns (uint256)
    {
        return _tUnclaimedRewards;
    }

    function remainingLotteryTime() public view returns (uint256)
    {
        return _lotteryStart + _lotteryDuration - block.timestamp;
    }

    function totalTicketsBought() public view returns (uint256)
    {
        return _ticketCount;
    }

    function totalTicketHolders() public view returns (uint256)
    {
        return _holderCount;
    }

    function ticketBalanceOf(address account) public view returns (uint256)
    {
        uint256 index = _holderIndexes[account];

        if(_ticketBalances[index].timestamp == _lotteryStart)
        {
            return _ticketBalances[index].balance;
        }

        return 0;
    }

    function unclaimedRewardsOf(address account) public view returns (uint256)
    {
        return _tRewards[account];
    }

    function _lotteryFinished() internal view returns (bool)
    {
        return (block.timestamp > _lotteryStart + _lotteryDuration);
    }

    function _restartLottery() internal 
    {
        _lotteryStart = block.timestamp;
        _lotteryDuration = 7 days;
        _ticketCount = 0;
        _holderCount = 0;
    }

    /*
        Chainlink functions
    */

    //Requests randomness 
    function requestRandomTicket() internal returns (bytes32 requestId) 
    {
        require(LINK.balanceOf(address(this)) >= _vrfFee, "Not enough LINK - fill contract with faucet");
        _vrfLocked = true;
        return requestRandomness(_vrfKeyHash, _vrfFee);
    }

    //Callback function used by VRF Coordinator
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override 
    { 
        _drawLottery(randomness);
    }
}